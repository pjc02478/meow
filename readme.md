meow
====

![workflow](https://github.com/pjc02478/meow/actions/workflows/node.js.yml/badge.svg)

Setup
----
이 프로젝트는 `yarn` 을 사용합니다.

`.env` 파일을 생성하고 아래 값을 입력합니다.
```
API_ENDPOINT=
API_KEY=
```
* `API_ENDPOINT`(Optional): 기본값(`https://api.thecatapi.com/v1`) 에서 변경하고 싶을 때만 지정합니다.
* `API_KEY`(Required): 발급받은 api key를 입력합니다.

```
yarn
yarn android
```


Comments
----
`redux` 혹은 `mobx` 등을 사용해 정석적이고 깔끔한 코드를 작성하는 방법도 있었습니다만,
단순히 시간을 들여 일반적인 코드를 작성하는 것 보다는, 평소 해보고 싶었지만 업무로써 만드는 프로덕트에는 적용하기 힘들거나/시기를 놓쳤던 아이디어들을 적용해보는 시간을 가지는것으로 했습니다.
<br/>
이 방법이 과제를 검토해주시는 입장에서는 제가 어떤 개발자인지 조금 더 구체적으로 파악하실 수 있을 것 같고, 저에게 있어서도 아이디를 코드로 구현하면서 배우는게 많을 것 같았고 실제로도 이번 과제를 통해서 느끼는점이 많이 있었습니다.


UX 의 측면에서
----

### 로딩 없에기 - 에러 처리와 애니메이션의 결합

<img src="imgs/vote.gif" width="320px" />

CatAPI의 투표 API 호출 시, 응답이 오기까지 약 `400~500ms`의 시간이 걸립니다.<br/>
해당 시간동안 `아무것도 안하거나`, `Spinner 를 돌려서 대기하기` 보다는 즉시 다음 고양이 사진으로 넘어갈 수 있도록 하였습니다. 다만 네트워크 작업 특성 상 실패할 여지가 있기 때문에 __버튼 클릭 즉시 다음으로 넘어가면서도, 언제든지 다시 되돌아올 수 있어야 합니다__. <br/>
<br/>
이를 해결하기 위해 고의적으로 애니메이션을 넣었고, 요청 도중 결국 요청이 실패하더라도 애니메이션이 롤백되면서 이전 고양이 사진으로 돌아오게 됩니다.<br/>
이는 요청이 성공하거나, 실패할 경우 모두 자연스럽고 빠른 반응성의 UX를 제공하게 해줍니다.

### 앱의 첫 화면은 로딩이 보이지 않게

두 번째 요청부터는 `prefetch` 할 수 있지만, 첫번째 요청은 무조건 시간이 필요합니다.<br/>

CatAPI에서 제공하는 고양이 사진의 주소는 가져오는데 __1초 이상__ 걸리는 경우가 많습니다. 따라서 메인 화면이 로딩되었지만 고양이 사진은 하얀화면 상태로 나오는 경우가 많았습니다.<br/>

`react-native-splash-screen`과 직접 제작한
[InitialImageLoader](/src/component/vote/InitialImageLoader.tsx) 컴포넌트를 이용해 고양이 사진이 전부 로딩되서 완전하게 렌더링이 된 시점에 첫 화면이 보일 수 있도록 했습니다.

### 다음 사진 미리 가져오기

간단하고 많이 쓰이는 방법이지만, 현재 보이는 고양이 사진만 로드하는것이 아니라 다음에 보일 2개의 고양이 사진을 미리 백그라운드에서 로드합니다.<br/>
`FastImage.preload` 를 사용해서 간단히 처리했습니다.


### 북마크 사진 미리 가져오기

[withPrefetch](/src/data/withPrefetch.tsx) 를 작성해 북마크의 1번째 페이지는 앱 시작과 함께 미리 로드할 수 있도록 했습니다.<br/>
<br/>
실제 프로덕션 앱에서는 모든 데이터가 prefetch 되야하는게 아니기 때문에 선택적으로 prefetch될 수 있어야 하고, 이를 위해 `withPrefetch`는 AOP 혹은 React의 HOC과 비슷한 형태로 동작합니다. <br/>
<br/>
이러한 구조로 된 이유는 처음 캐싱하는 구조를 구상할 때, 아래와 같은 목표가 있었습니다.

* 캐싱이 데이터 가져오기나 UI 로직에서 완전하게 독립적이 되어야 합니다.
* 캐싱 기능 자체를 간편하게 넣거나 뺄 수 있어야 합니다.

(처음 구상에서는 [캐싱](https://github.com/pjc02478/meow/issues/2)이 가능한 구조로 생각하였지만, 캐싱이 버그를 야기할 수 있고, 캐싱이 필요할정도로 빨라야 하는 데이터가 아니라 `미리 가져오기`로 변경하였습니다.)

기술적인 측면에서
----

### 전역적인 에러 처리와 재시도

모든 액션에 아래와 같이 에러 핸들링을 하는 방법은 깔끔하지 못합니다.
```tsx
const onSubmit = async () => {
  try{
    await call();
  } catch{
  }
}
```

이를 해결하기 위해 __전역적인 에러 핸들러__ 를 작성하였습니다.
이 프로젝트에서는 최소한으로 아래 2가지 기능을 가진 에러 핸들러를 작성하였습니다.

* [retryHandler - 재시도 가능한 API](src/data/handler/retryHandler.tsx)
* [toastHandler - 실패했지만 실패 메세지만 띄우고 마는 API](src/data/handler/toastHandler.tsx)

에러 핸들러는 `에러` 객체 이외에도 `retry` 와 `reject` 두개의 함수를 인자로 받습니다.<br/>
`retry` 호출 시 API 요청을 그대로 한번 더 실행합니다. 원래의 promise는 재시도 요청이 끝날때까지 계속 대기합니다. (재시도를 여러번 할 수 있습니다. 최종적으로 요청은 resolve되거나, `reject` 가 호출될 때 까지 대기합니다.)<br/>
`reject` 는 이 요청을 실패로 간주하고, throw합니다.<br/>
<br/>
이 방법의 장점은 아래와 같습니다.

* 에러에 대한 처리를 UI 컴포넌트로부터 분리합니다. (실패로 간주될 경우 throw 하기 때문에 여전히 UI 컴포넌트에서 try~catch를 통한 추가적인 처리를 수행할 수 있습니다.)
* api와 에러 핸들러를 바인딩합니다. (기존에는 UI와 에러 핸들러가 바인딩된 형태였습니다.)
* 재시도 처리가 깔끔합니다.
  * 만약 `await modifyUser();` 코드 가 실패하고, 에러 핸들러가 `retryHandler` 로 지정되었을 경우 해당 Promise는 `재시도해서 성공했거나`, `유저가 재시도 하지 않기로 했거나` 둘 중 하나의 __최종적인 결과__ 가 나올 때 까지 계속 대기합니다.
  * `호출자` 에게 `재시도` 라는 중간과정은 신경쓰지 않아도 되는 부분이 되도록 했습니다.
  * 에러 핸들러를 지정하지 않으면 기존의 flow와 동일하게 동작합니다. 만약 `재시도` 과정을 신경쓰지 않는게 아니라 컨트롤하고싶다면, 해당 구현 또한 제약이 없습니다.


#### 짧은 버전의 설명

<img src="/imgs/retry.gif" width="320px" />

위처럼 동작하는 코드는 아래 1줄의 api 요청으로 되어 있습니다.

```tsx
const onRemoveBookmark = (bookmark: IBookmark) => {
  removeBookmark(bookmark.id);
};
```
